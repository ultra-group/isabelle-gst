<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‚ÄπTools/gst_features.ML‚Ä∫</title>
</head>


<body>
<div class="head">
<h1>File ‚ÄπTools/gst_features.ML‚Ä∫</h1>
</div>

<pre class="source"><span class="comment1">(*A feature is a represented as an ML record, with the following definition: *)</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">gst_feature</span> <span class="main">=</span> <span class="entity">Feature</span> 
<span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span> name <span class="main">:</span> string<span class="main">,</span> 
     deps <span class="main">:</span> string list<span class="main">,</span>
     feature_sig <span class="main">:</span> <span class="main">(</span>string * typ * mixfix<span class="main">)</span> list<span class="main">,</span>
     simple_defs <span class="main">:</span> <span class="main">(</span>string * term<span class="main">)</span> list<span class="main">,</span>
     theory <span class="main">:</span> <span class="main">(</span>string * term<span class="main">)</span> list<span class="main">,</span>
     child_pred <span class="main">:</span> string option <span class="main">}</span> 

<span class="comment1">(* A feature declaration ‚ÄπF‚Ä∫ is an ML record consists of the following fields:

  name : string 
    -- The name of the feature. 
       Used as a prefix for the names of the locales L(F), shown below.
          
  deps : string list
    -- A list of the names of features that F depends on.
       Used for gathering locale imports when generating features

  feature_sig : (string * typ * mixfix) list
    -- A list of declarations (iden, œÑ, ùîê) for the signature of the theory,
       Where ‚Äπiden‚Ä∫ is the name of the constant, œÑ is the Isabelle 
       including any soft-types that are not given by simple definition.

  simple_defs : (string * term) list
    -- A list of pairs of strings and terms ‚Äπ(iden, B)‚Ä∫,
       used for forming simple definitions ‚Äπiden ‚â° B‚Ä∫. 

  theory : (string * term) list
    -- A list of pairs of strings and terms ‚Äπ(str,B)‚Ä∫ representing the axioms of the feature. 
       Can include partial-typings of the constants given by feature_sig.
       ‚ÄπB‚Ä∫ must be a term of type ‚Äπbool‚Ä∫ and can make use of the constants 
       given by feature_sig and simple_defs.  
       ‚Äπstr‚Ä∫ is the name given to the axiom ‚ÄπB‚Ä∫.
       
  child_pred : string option
    -- The name of an optional child predicate given in either ‚Äπfeature_sig‚Ä∫ or ‚Äπsimple_defs‚Ä∫.
      Afterwards, this constant is used for building well-foundedness axioms for feature combinations.
*)</span>


<span class="comment1">(* A feature ‚ÄπF‚Ä∫ has 2 locales associated with it: 
    L(F) = { &lt;NAME&gt;_sig,           -- Fixes parameters for: 
                                   (a). the signature of the feature,
                                   (b). the constant used for the feature's default value, and 
                                   (c). constants for soft types not given by simple definition.  
                                   Also adds simple definitions provided by the user.
                                   The user should never see this locale, 
                                   or do any development within its context. *)</span>

<span class="comment1">(*Takes a name, list of names, a signature, and simple definitions, and a local theory,
  and returns a pair ‚Äπ(loc, lthy)‚Ä∫ where loc is the name of the generated locale (i.e &lt;NAME&gt;_sig)
  and lthy is a local theory updated with the registration of ‚Äπloc‚Ä∫, 
  and with the definitions from ‚Äπdefs‚Ä∫ *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_sig_locale</span> <span class="entity">name</span> <span class="entity">deps</span> <span class="entity">decls</span> <span class="entity">defs</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">get_thy</span> <span class="entity">lthy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imports</span> <span class="main">=</span> <span class="entity">locale_expr</span> <span class="entity">thy</span> <span class="main">(</span>map <span class="main">(</span><span class="entity">get_locale</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">deps</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_decl</span> <span class="main">=</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_default"</span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'d</span></span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">nsyn</span><span class="main">)</span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixes</span> <span class="main">=</span> <span class="entity">def_decl</span> :: map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span><span class="entity">typ</span><span class="main">,</span><span class="entity">syn</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> SOME <span class="entity">typ</span><span class="main">,</span> <span class="entity">syn</span><span class="main">)</span><span class="main">)</span> <span class="entity">decls</span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">loc</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_locale</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_sig"</span><span class="main">)</span> <span class="entity">imports</span> <span class="entity">fixes</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">loc</span><span class="main">,</span> <span class="entity">make_defns</span> <span class="entity">lthy'</span> <span class="entity">defs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_sig_class</span> <span class="entity">name</span> <span class="entity">deps</span> <span class="entity">decls</span> <span class="entity">defs</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imports</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span><span class="entity">get_class</span> <span class="entity">lthy</span><span class="main">)</span> <span class="entity">deps</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_decl</span> <span class="main">=</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_default"</span><span class="main">,</span> SOME <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted"><span class="tfree">'a</span></span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">nsyn</span><span class="main">)</span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixes</span> <span class="main">=</span> <span class="entity">def_decl</span> :: map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span><span class="entity">typ</span><span class="main">,</span><span class="entity">syn</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> SOME <span class="entity">typ</span><span class="main">,</span> <span class="entity">syn</span><span class="main">)</span><span class="main">)</span> <span class="entity">decls</span> 
  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">loc</span><span class="main">,</span> <span class="entity">lthy'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_class</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_sig"</span><span class="main">)</span> <span class="entity">imports</span> <span class="entity">fixes</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lthy</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">loc</span><span class="main">,</span> <span class="entity">make_defns</span> <span class="entity">lthy'</span> <span class="entity">defs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* EXAMPLE 2.1:  Consider the following Isar code:

local_setup 
  ‚Äπ snd o mk_sig_locale "Nat" [] 
        [("Nat", @{typ "'d ‚áí bool"}, nsyn), 
         ("Zero", @{typ "'d"}, nsyn), 
         ("Succ", @{typ "'d ‚áí 'd"}, nsyn)]
        [("AddTwo", @{term "(Œªn :: 'd. Succ (Succ n))"}}),
         ("NonZero", @{term "(Œªn :: 'd. n ‚â† Zero)})] ‚Ä∫
         
Running the above Isar code has the same effect as running the following Isar code: 
  
locale Nat_sig = 
  fixes Nat_default :: "'d
    and Nat :: "'d ‚áí bool" 
    and Zero :: "'d"
    and Succ :: "'d ‚áí bool"
 
context Nat_sig begin
 
definition "AddTwo ‚â° (Œªn :: 'd. Succ (Succ n))"
definition "NonZero ‚â° (Œªn :: 'd. n ‚â† Zero)"

end *)</span>


<span class="comment1">(* EXAMPLE 2.2: Consider the following Isar code:

local_setup 
  ‚Äπ snd o mk_sig_locale "OrdRec" ["GZF", "Ordinal"]
      [("predSet", @{typ "'d ‚áí 'd"}, nsyn), 
        ("supOrd", @{typ "'d ‚áí 'd"}, nsyn), 
        ("OrdRec", @{typ "[['d, 'd ‚áí 'd] ‚áí 'd, ['d,'d] ‚áí 'd", 'd, 'd] ‚áí 'd}, nsyn)]‚Ä∫
      [] ‚Ä∫

Running the above Isar code has the same effect as running the following Isar code: 

locale OrdRec_sig = 
    GZF GZF_default Set Mem Emp Union Pow Succ Inf Repl 
  + Ordinal Ordinal_default Ord lt zero succ omega
  for GZF_default :: "'d"
  and Set :: "'d ‚áí bool"
  and Mem :: "'d ‚áí 'd ‚áí bool"  (infixl ‚Äπ‚àà‚Ä∫ 50)
  and Emp :: "'d"  (‚Äπ‚àÖ‚Ä∫)
  and Union :: "'d ‚áí 'd"  (‚Äπ‚ãÉ _‚Ä∫ [90] 90)
  and Pow :: "'d ‚áí 'd"  (‚Äπùí´ _‚Ä∫ [90] 90)
  and Succ :: "'d ‚áí 'd"
  and Inf :: "'d"
  and Repl :: "'d ‚áí ('d ‚áí 'd ‚áí bool) ‚áí 'd"  (‚Äπ‚Ñõ‚Ä∫)
  and Ordinal_default :: "'d"
  and Ord :: "'d ‚áí bool"
  and lt :: "'d ‚áí 'd ‚áí bool"  (infixl ‚Äπ&lt;‚Ä∫ 50)
  and zero :: "'d"  (‚Äπ0‚Ä∫)
  and succ :: "'d ‚áí 'd"
  and omega :: "'d"  (‚Äπœâ‚Ä∫) +
  fixes OrdRec_default :: "'d"
    and predSet :: "'d ‚áí 'd"
    and supOrd  :: "'d ‚áí 'd"
    and OrdRec :: "('d ‚áí 'd) ‚áí 'd" 

Our code is used for a special case of locale import where the free variable
is always kept the same. Perhaps this always happens with typeclasses?

*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_main_locale</span> <span class="entity">name</span> <span class="entity">axioms</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">get_thy</span> <span class="entity">lthy</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">import</span> <span class="main">=</span> <span class="entity">locale_expr</span> <span class="entity">thy</span> <span class="main">[</span><span class="entity">get_locale</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_sig"</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_locale</span> <span class="entity">name</span> <span class="entity">import</span> <span class="main">[</span><span class="main">]</span> <span class="entity">axioms</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span> 

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_main_class</span> <span class="entity">name</span> <span class="entity">axioms</span> <span class="entity">lthy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">import</span> <span class="main">=</span> <span class="main">[</span><span class="entity">get_class</span> <span class="entity">lthy</span> <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"_sig"</span><span class="main">)</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_class</span> <span class="entity">name</span> <span class="entity">import</span> <span class="main">[</span><span class="main">]</span> <span class="entity">axioms</span> <span class="entity">lthy</span> <span class="keyword2"><span class="keyword">end</span></span>



<span class="comment1">(*! ! ! ! ! ! WARNING: UNDER CONSTRUCTION ! ! ! ! *)</span>
<span class="comment1">(*
             &lt;NAME&gt;,               -- The main locale. Inherits solely from ‚ÄπNAME‚Ä∫_sig. 
                                   Assumes (a). the axioms of the theory, 
                                           (b). the partial-typings of the signature            
                                   The user works within this locale to develop definitions
                                   &amp; theorems for a feature's interface.

   EXAMPLE:

} *)</span>



<span class="comment1">(* 
fun suffixes [] = []
  | suffixes xs = map ((fn s =&gt; "_" ^ s) o Int.toString) (1 upto (length xs))

fun mk_dom_preds (str,styp) = 
 let fun preds str [] = error ("Error, no soft type assigned for " ^ str) 
       | preds str [(x,_)] = [("ran_" ^ str, x)]
       | preds str ((x,n)::xs) = ("dom_" ^ str ^ n, x) :: preds str xs 
      val styps = get_styps styp
      val sufxs = case length styps of
                    2 =&gt; ["",""]
                  | _ =&gt; suffixes styps 
 in preds str (get_styps styp ~~ sufxs) end
*)</span>
<span class="comment1">(*
fun mk_feature_locale (f as feature {name, feature_sig, deps, styp_fixes, styp_defs,...}) lthy = let
  val (loc, lthy') = mk_feature_defs_locale name feature_sig (get_fdeps f) styp_fixes styp_defs lthy
  val thy' = Local_Theory.exit_global lthy'
  val imports = locale_expr thy' [loc] 
  val (_,lthy'') = mk_locale (get_fname f) imports [] (mk_feature_assms f) lthy'
  in lthy'' end  *)</span> 


<span class="comment1">(*Probably don't need: 

(*If ‚Äπiden‚Ä∫ is a name, and ‚Äπstyp‚Ä∫ is a soft-type on a œÑ, 
  then ‚Äπmk_styp_assm iden styp‚Ä∫ returns the pair ‚Äπ(iden_typ, Free (iden, œÑ) : P)‚Ä∫.
  This pair is later handed to the locale 'assumption' machinery, 
  so that 'iden_typ' is the name given to the fact ‚Äπiden : P‚Ä∫ in the context
  of a locale that uses this assumption.*)
fun mk_styp_assm iden styp = 
  let val typ = domain_type (fastype_of styp)
      val prop = HOLogic.mk_Trueprop (mk_styping_trm (Free (iden, typ)) typ styp)
  in (iden ^ "_typ", prop) end*)</span>
</pre>
</body>

</html>